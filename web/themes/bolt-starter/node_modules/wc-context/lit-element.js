const orphanMap = {};
const resolved = Promise.resolve();
const orphanResolveQueue = {
  contexts: new Set(),
  running: false,

  add(context) {
    this.contexts.add(context);

    if (!this.running) {
      this.running = true;
      resolved.then(() => {
        this.contexts.forEach(context => {
          const orphans = orphanMap[context];
          orphans.forEach(orphan => {
            const event = sendContextEvent(orphan, context);

            if (event.detail.handled) {
              orphans.delete(orphan);
            }
          });
        });
        this.contexts.clear();
        this.running = false;
      });
    }
  }

};

function addOrphan(el, name) {
  const orphans = orphanMap[name] || (orphanMap[name] = new Set());
  orphans.add(el);
}

function removeOrphan(el, name) {
  const orphans = orphanMap[name];

  if (orphans) {
    orphans.delete(el);
  }
}

function sendContextEvent(el, name) {
  const event = new CustomEvent(`context-request-${name}`, {
    detail: {},
    bubbles: true,
    cancelable: true,
    composed: true
  });
  el.dispatchEvent(event);
  return event;
}

function registerProvidedContext(el, name, providedContexts) {
  const observerMap = el.__wcContextObserverMap || (el.__wcContextObserverMap = {});
  const observers = observerMap[name] || (observerMap[name] = []);
  const orphans = orphanMap[name];
  el.addEventListener(`context-request-${name}`, event => {
    event.stopPropagation();
    const targetEl = event.target;
    const value = providedContexts[name];
    const context = targetEl.context;
    const oldValue = context[name];

    if (oldValue !== value) {
      context[name] = value;

      if (targetEl.contextChangedCallback) {
        targetEl.contextChangedCallback(name, oldValue, value);
      }
    }

    observers.push(targetEl);
    event.detail.handled = true;
  });

  if (orphans && orphans.size) {
    orphanResolveQueue.add(name);
  }
}

function observeContext(el, name) {
  const event = sendContextEvent(el, name);

  if (!event.detail.handled) {
    addOrphan(el, name);
  }
}

function unobserveContext(el, name) {
  removeOrphan(el, name);
}

function notifyContextChange(el, name, value) {
  const observerMap = el.__wcContextObserverMap;
  const observers = observerMap && observerMap[name];

  if (observers) {
    observers.forEach(observer => {
      const context = observer.context;
      const oldValue = context[name];

      if (oldValue !== value) {
        context[name] = value;

        if (observer.contextChangedCallback) {
          observer.contextChangedCallback(name, oldValue, value);
        }
      }
    });
  }
}

const initializedElements = new WeakSet();

const withContext = Base => {
  return class extends Base {
    get context() {
      return this.__wcContext || (this.__wcContext = {});
    }

    connectedCallback() {
      super.connectedCallback();
      const observedContexts = this.constructor.observedContexts;

      if (observedContexts) {
        observedContexts.forEach(context => observeContext(this, context));
      }

      if (!initializedElements.has(this)) {
        const providedContextConfigs = this.constructor.providedContexts;

        if (providedContextConfigs) {
          const providedContexts = this.__wcProvidedContexts || (this.__wcProvidedContexts = {});
          const mappedProps = this.__wcMappedProps || (this.__wcMappedProps = {});
          Object.keys(providedContextConfigs).forEach(name => {
            const config = providedContextConfigs[name];
            const property = typeof config === 'string' ? config : config.property;
            providedContexts[name] = property ? this[property] : config.value;

            if (property) {
              mappedProps[name] = property;
            }

            registerProvidedContext(this, name, providedContexts);
          });
        }

        initializedElements.add(this);
      }
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      const observedContexts = this.constructor.observedContexts;

      if (observedContexts) {
        observedContexts.forEach(context => unobserveContext(this, context));
      }
    }

    shouldUpdate(changedProperties) {
      const shouldChange = super.shouldUpdate(changedProperties);
      const mappedProps = this.__wcMappedProps;

      if (mappedProps) {
        const providedContexts = this.__wcProvidedContexts || (this.__wcProvidedContexts = {});
        Object.keys(mappedProps).forEach(contextName => {
          const property = mappedProps[contextName];

          if (changedProperties.has(property)) {
            const value = this[property];
            providedContexts[contextName] = value;
            notifyContextChange(this, contextName, value);
          }
        });
      }

      return shouldChange;
    }

  };
};

export { withContext };
//# sourceMappingURL=lit-element.js.map
